---
marp: true
title: Marp
paginate: true
style: |
  .red {
    color: red;
  }
  .green {
    color : green;
  }
  .blue {
    color : blue;
  }
---

# 클로저 사용법

## 7.1 클로저 관찰하기

> 클로저란 내부 함수가 외부 스코프에 있는 변수를 참조하는 것
> 클로저는 함수에서만 일어나는 함수의 동작 (오직 함수에만 클로저가 있다.)

### 7.1.1 화살표 함수의 스코프

```
function lookupStudent(studentID){
    function greeting(greeting){
         var student = student.find(student => student.id == studentID);
        return `${greeting}, ${student.name} 님!`
    }
}
```

> 화살표 함수조차 클로저를 형성 할 수 있다!

---

### 7.1.2 추가되는 클로저

> 클로저는 함수 인스턴스에 따라 다르게 생성된다.
> 실제로 클로저의 동작은 실행 시점에 함수 인스턴스에 따라 달라지는 특성

```
function adder(num1){
    return function addTo(num2){
        return num1+num2;
    }
}

var addTo10 = adder(10);
var addTo42 = adder(42);

addTo(15) // 25
addTo(9)  // 51
```

- 외부 함수 adder()가 실행될 때마다 내부 함수 addTo()의 새로운 인스턴스가 생성됨
- 새로운 인스턴스에는 새로운 클로저가 생성

---

### 7.1.3 스냅숏이 아닌 라이브 링크

> 클로저는 실시간으로 변수 자체에 언제든 접근할 수 있도록 관계를 맺어주는 라이브 링크
> 이렇기에 클로저를 통해 값을 읽고/수정 할 수 있다.

- 아래 그림[7] 처럼 adder()이 호출 될 때마다 변수 num1을 포함하는 스코프가 생성되고
- addTo()의 인스턴스도 새로 생성
- 함수 인스턴스인 addTo10(), addTo42()는 전역 스코프에서 일어남

</br>
</br>
</br>
</br>
</br>
👇 그림[7] 함수 인스턴스와 스코프 간에 살아 있는 관계

---

![image](/public/closure.jpeg)

---

추가적인 클로적의 특징

1. 내부 함수를 감싸는 외부 스코프가 존재하기만 해도 클로저가 된다.
   ```
   var hit;
   {
    let count=0;
    hits=function getCurrent(){
        count = count+1;
        return count;
    };
   }
   hit(); // 1
   hit(); // 2
   hit(); // 3
   ```

---

2. setTimeout(), 이벤트 핸들러에 전달하는 비동기 작업이 있더라도 클로저의 동작이 바뀌지 않는다.
   ```
    var keeps=[];
    for(let i=0 ; i < 3 ; i++){
        keeps[i] = function keepEachI(){
            return i;
        };
    }
    keeps[0]() // 0;
    keeps[1]() // 1;
    keeps[2]() // 2;
   ```
   📌 TIP : for 루프에서 초깃값을 let으로 선언하면 반복 마다 새로운 변수가 생성된다고 배웠었다.

---

클로저가 아닙니다의 특징

1. 전역 변수에 접근 할 수 있는 것은 렉시컬 스코프 법칙 때문

   ```
   var student = [
    {id:14 , name:"가"},
    {id:12 , name:"나"},
    {id:112 , name:"다"},
    {id:6 , name:"라"}
   ];

   function getFirstStudent(){
    return function firstStudent(){
        return student[0].name;
    }
   }

   var student = getFirstStudent();

   student();
   ```

---

2. 한번도 해당 변수에 접근하지 않은 경우

   ```
   function lookup(studentID){
    return function nobody(){
        var msg = '노바디';
        console.log(msg);
    };
   }

   var student = lookup(112);
   ```

3. 함수를 호출 하지 않는 경우
   ```
   function greetStudent(StudentName){
       return function greeting(){
           console.log(`hello #{StudentName}`)
       }
   }
   greetStudent('가나다');
   ```

---

### 7.1.6 클로저의 정의

📍 핵심

- 반드시 함수와 관련되어야 한다.
- 외부 스코프의 변수를 적어도 하나 이상 참조해야 한다.
- 참조하려는 변수가 있는 스코프 체인의 다른 분기에서 함수를 호출해야 한다.

---

### 7.2 클로저 생명주기와 가비지 컬렉션

> 클로저는 변수의 GC를 예기치 않게 막아 메모리 사용을 급증시키는 요인이 될 수 있다.
> 더 이상 필요하지 않는 함수 참조는 제때 삭제하는게 중요하다.
