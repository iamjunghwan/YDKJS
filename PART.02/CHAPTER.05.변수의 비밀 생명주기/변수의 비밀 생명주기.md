---
marp: true
title: Marp
paginate: true
style: |
  .red {
    color: red;
  }
  .green {
    color : green;
  }
  .blue {
    color : blue;
  }
---

# 변수의 비밀 생명주기

## 변수 사용 가능 시점 🎬

<br>

greeting()는 선언하기전에 실행 했는데 왜 작동할까? 🤔

```
greeting();

function greeting(){
  console.log("안녕하세요");
}
```

바로, 함수 호이스팅 때문이다.

---

### 호이스팅 🚀

> 선언은 스코프 아래에 있더라도 스코프 시작 부분에서 변수의 가시성이 확보되는 걸 뜻한다.

<br>

📌 Note
함수 선언문 : 함수를 선언하면 함수 이름에 해당하는 식별자가 스코프 최상단에 등록되고 함수 참조로 그 값이 자동으로 초기화된다.

<br>

📌 Note
let & const 👉 블록 스코프
var & 함수 선언문 👉 함수 스코프

---

## 선언문과 표현식에서의 호이스팅 차이

```
1. greeting();
2. // TypeError ( 'undefined' is not a function || 'greeting' is not a function )
3.
4. var greeting = function greeting(){
5.   console.log("안녕하세요");
6. }
```

<br>

TypeError은 허용되지 않는 값을 가지고 무언가를 하려고 할 때 발생하는 오류인데 왜 나올까? 🤔

> 함수가 아닌 <span class='red'>값을 호출</span>하려고 해서 오류가 발생한 것이다.

---

🕺 동작

1. var로 선언한 변수는 호이스팅 + 스코프가 시작될 때 undefined로 자동 초기화
2. 초기화 이후에 스코프 전체에서 이 변수를 사용 가능
3. 4번째 줄에 있는 함수 참조 할당이 실행되기 전까지, 1번째 줄에 있는 greeting은 기본값인 undefined로 남아 있게 된다.

📍 정리

1. 📢 함수 선언문은 호이스팅 되고 해당 함숫값으로 초기화
2. ☁️ var는 호이스팅 되고 undefined로 초기화
3. 💋 함수 표현식에서는 코드가 실행되기 전까지 var greeting는 undefined이고, 런타임에 해당 함수를 호출했을 때 실제 함수가 할당된다

---

## 변수 호이스팅

```
greeting = "안녕하슈?";

console.log(greeting); // 안녕하슈?

var greeting = '굿';
```

이런식으로 동작 👇

```
                          // 이유 🔥
var greeting;             // 선언만 먼저 처리됨 → 초기값: undefined

greeting = '안녕하슈?';     // 전역 변수 greeting에 값 할당
console.log(greeting);    // '안녕하슈?'

greeting = '굿';          // 다시 값 덮어쓰기

```

---
